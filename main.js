/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
If you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AgentKitPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/core/Orchestrator.ts
var import_obsidian = require("obsidian");

// src/core/utils.ts
var _Logger = class {
  static setDebugMode(debug) {
    _Logger.isDebug = debug;
  }
  static log(message, ...args) {
    if (_Logger.isDebug) {
      console.log(`[OAK] ${message}`, ...args);
    }
  }
  static warn(message, ...args) {
    console.warn(`[OAK] ${message}`, ...args);
  }
  static error(message, ...args) {
    console.error(`[OAK] ${message}`, ...args);
  }
};
var Logger = _Logger;
Logger.isDebug = false;

// src/core/Orchestrator.ts
var Orchestrator = class {
  constructor(plugin) {
    this._isRunning = false;
    this.agents = [];
    this.plugin = plugin;
  }
  get isRunning() {
    return this._isRunning;
  }
  registerAgent(agent) {
    this.agents.push(agent);
    if (!this.plugin.queueData[agent.queueName]) {
      this.plugin.queueData[agent.queueName] = [];
    }
    Logger.log(`Registered Agent: ${agent.constructor.name} -> Queue: ${agent.queueName}`);
  }
  async addToQueue(queueName, item) {
    if (!this.plugin.queueData[queueName]) {
      this.plugin.queueData[queueName] = [];
    }
    item.retries = 0;
    if (!item.id)
      item.id = Date.now().toString();
    this.plugin.queueData[queueName].push(item);
    await this.plugin.persistence.saveQueueData(this.plugin.queueData);
    Logger.log(`Task added to ${queueName}`);
  }
  start() {
    if (this._isRunning)
      return;
    this._isRunning = true;
    new import_obsidian.Notice("ğŸš€ OAK å¼•æ“å·²å¯åŠ¨");
    Logger.log("Engine started");
    this.loop().catch((err) => Logger.error("Loop error:", err));
  }
  stop() {
    this._isRunning = false;
    new import_obsidian.Notice("ğŸ›‘ OAK å¼•æ“å·²åœæ­¢");
    Logger.log("Engine stopped");
  }
  async loop() {
    if (!this._isRunning)
      return;
    let workDone = false;
    for (const agent of this.agents) {
      if (!this._isRunning)
        break;
      const queueName = agent.queueName;
      const queue = this.plugin.queueData[queueName];
      if (queue && queue.length > 0) {
        const item = queue[0];
        try {
          Logger.log(`Processing task in ${queueName}...`);
          const success = await agent.process(item);
          if (success) {
            queue.shift();
            workDone = true;
          } else {
            throw new Error("Agent process returned false.");
          }
        } catch (error) {
          Logger.error(`Agent ${agent.constructor.name} failed:`, error);
          workDone = true;
          const failedItem = queue.shift();
          if (failedItem) {
            failedItem.retries = (failedItem.retries || 0) + 1;
            const maxRetries = this.plugin.settings.maxRetries || 3;
            if (failedItem.retries < maxRetries) {
              queue.push(failedItem);
              Logger.warn(`Task retrying (${failedItem.retries}/${maxRetries})`);
            } else {
              Logger.error(`Task max retries reached. Discarding.`);
              new import_obsidian.Notice(`ä»»åŠ¡å·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œå·²è¢«æ”¾å¼ƒã€‚`);
            }
          }
        } finally {
          await this.plugin.persistence.saveQueueData(this.plugin.queueData);
        }
      }
    }
    const delay = workDone ? 100 : 2e3;
    if (this._isRunning) {
      setTimeout(() => {
        this.loop().catch((err) => Logger.error("Loop timeout error:", err));
      }, delay);
    }
  }
};

// src/core/LLMProvider.ts
var import_obsidian2 = require("obsidian");
var LLMProvider = class {
  constructor(getSettings) {
    this.getSettings = getSettings;
    // å†…å­˜ä¸­ç»´æŠ¤ Key çš„çŠ¶æ€ï¼ˆé‡å¯ Obsidian åé‡ç½®ï¼‰
    this.keyUsageOpenAI = /* @__PURE__ */ new Map();
    this.keyUsageGoogle = /* @__PURE__ */ new Map();
    // å¤±è´¥å†·å´æ—¶é—´ (ç§’)
    this.COOLDOWN_SECONDS = 300;
  }
  /**
   * å¯¹å¤–çš„ä¸»å…¥å£ï¼šæ™ºèƒ½è°ƒåº¦
   */
  async chat(prompt) {
    const settings = this.getSettings();
    const provider = settings.llmProvider;
    try {
      if (provider === "openai") {
        return await this.tryOpenAIFirst(prompt);
      } else {
        return await this.tryGoogleFirst(prompt);
      }
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      Logger.error("[LLM Fatal Error]", error);
      new import_obsidian2.Notice(`AI å…¨çº¿å´©æºƒ: ${msg}`);
      return "";
    }
  }
  // --- ç­–ç•¥å±‚ ---
  async tryOpenAIFirst(prompt) {
    try {
      return await this.callOpenAI(prompt);
    } catch (e) {
      Logger.warn("OpenAI failed, attempting failover to Google...", e);
      if (this.getKeys(this.getSettings().googleApiKey).length > 0) {
        new import_obsidian2.Notice("OpenAI æš‚æ—¶ä¸å¯ç”¨ï¼Œæ­£åœ¨åˆ‡æ¢è‡³ Google...");
        return await this.callGoogle(prompt);
      }
      throw e;
    }
  }
  async tryGoogleFirst(prompt) {
    try {
      return await this.callGoogle(prompt);
    } catch (e) {
      Logger.warn("Google failed, attempting failover to OpenAI...", e);
      if (this.getKeys(this.getSettings().openaiApiKey).length > 0) {
        new import_obsidian2.Notice("Google æš‚æ—¶ä¸å¯ç”¨ï¼Œæ­£åœ¨åˆ‡æ¢è‡³ OpenAI...");
        return await this.callOpenAI(prompt);
      }
      throw e;
    }
  }
  // --- æ‰§è¡Œå±‚ (å«å¤š Key è½®æ¢) ---
  async callOpenAI(prompt) {
    const settings = this.getSettings();
    const keys = this.getAvailableKeys(settings.openaiApiKey, "openai");
    if (keys.length === 0)
      throw new Error("OpenAI API Key è€—å°½æˆ–æœªé…ç½® (æ‰€æœ‰ Key å‡åœ¨å†·å´ä¸­)");
    let lastError = null;
    for (const apiKey of keys) {
      try {
        Logger.log(`Trying OpenAI Key: ...${apiKey.slice(-4)}`);
        const result = await this._requestOpenAI(apiKey, settings, prompt);
        this.resetCooldown(apiKey, "openai");
        return result;
      } catch (error) {
        Logger.warn(`OpenAI Key ...${apiKey.slice(-4)} failed: ${error.message}`);
        lastError = error;
        if (this.isQuotaError(error)) {
          this.applyCooldown(apiKey, "openai");
        }
      }
    }
    throw lastError || new Error("All OpenAI keys failed.");
  }
  async callGoogle(prompt) {
    const settings = this.getSettings();
    const keys = this.getAvailableKeys(settings.googleApiKey, "google");
    if (keys.length === 0)
      throw new Error("Google API Key è€—å°½æˆ–æœªé…ç½®");
    let lastError = null;
    for (const apiKey of keys) {
      try {
        Logger.log(`Trying Google Key: ...${apiKey.slice(-4)}`);
        const result = await this._requestGoogle(apiKey, settings, prompt);
        this.resetCooldown(apiKey, "google");
        return result;
      } catch (error) {
        Logger.warn(`Google Key ...${apiKey.slice(-4)} failed: ${error.message}`);
        lastError = error;
        if (this.isQuotaError(error)) {
          this.applyCooldown(apiKey, "google");
        }
      }
    }
    throw lastError || new Error("All Google keys failed.");
  }
  // --- åº•å±‚è¯·æ±‚ (Base Request) ---
  async _requestOpenAI(apiKey, settings, prompt) {
    const url = `${settings.openaiBaseUrl.replace(/\/$/, "")}/chat/completions`;
    const response = await (0, import_obsidian2.requestUrl)({
      url,
      method: "POST",
      headers: { "Content-Type": "application/json", "Authorization": `Bearer ${apiKey}` },
      body: JSON.stringify({
        model: settings.openaiModel,
        messages: [{ role: "user", content: prompt }],
        temperature: 0.7
      })
    });
    if (response.status >= 400)
      throw new Error(`OpenAI Status ${response.status}`);
    return response.json.choices[0].message.content.trim();
  }
  async _requestGoogle(apiKey, settings, prompt) {
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${settings.googleModel}:generateContent?key=${apiKey}`;
    const response = await (0, import_obsidian2.requestUrl)({
      url,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
    });
    if (response.status >= 400)
      throw new Error(`Google Status ${response.status}`);
    if (response.json.candidates && response.json.candidates.length > 0) {
      return response.json.candidates[0].content.parts[0].text.trim();
    }
    return "";
  }
  // --- è¾…åŠ©å·¥å…· ---
  getKeys(keyString) {
    if (!keyString)
      return [];
    return keyString.split("\n").map((k) => k.trim()).filter((k) => k.length > 0);
  }
  getAvailableKeys(keyString, provider) {
    const allKeys = this.getKeys(keyString);
    const map = provider === "openai" ? this.keyUsageOpenAI : this.keyUsageGoogle;
    const now = Date.now() / 1e3;
    return allKeys.filter((key) => {
      const usage = map.get(key);
      if (!usage)
        return true;
      return now >= usage.cooldown_until;
    });
  }
  isQuotaError(error) {
    const msg = (error.message || "").toLowerCase();
    if (msg.includes("429") || msg.includes("401") || msg.includes("403"))
      return true;
    if (msg.includes("quota") || msg.includes("rate limit") || msg.includes("insufficient"))
      return true;
    return false;
  }
  applyCooldown(key, provider) {
    const map = provider === "openai" ? this.keyUsageOpenAI : this.keyUsageGoogle;
    map.set(key, { cooldown_until: Date.now() / 1e3 + this.COOLDOWN_SECONDS });
    Logger.warn(`â„ï¸ Key ...${key.slice(-4)} å†·å´ 5 åˆ†é’Ÿ.`);
  }
  resetCooldown(key, provider) {
    const map = provider === "openai" ? this.keyUsageOpenAI : this.keyUsageGoogle;
    map.delete(key);
  }
};

// src/core/Persistence.ts
var import_obsidian3 = require("obsidian");
var Persistence = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = plugin.app;
    this.cacheDir = (0, import_obsidian3.normalizePath)(`${this.app.vault.configDir}/plugins/${this.plugin.manifest.id}/task_cache`);
    this.queueFile = (0, import_obsidian3.normalizePath)(`${this.app.vault.configDir}/plugins/${this.plugin.manifest.id}/queues.json`);
  }
  async init() {
    const adapter = this.app.vault.adapter;
    if (!await adapter.exists(this.cacheDir)) {
      await adapter.mkdir(this.cacheDir);
    }
  }
  // --- é˜Ÿåˆ—æ•°æ®ç®¡ç† ---
  async loadQueueData() {
    const adapter = this.app.vault.adapter;
    if (await adapter.exists(this.queueFile)) {
      try {
        const content = await adapter.read(this.queueFile);
        return JSON.parse(content);
      } catch (e) {
        Logger.error("Failed to load queue data:", e);
        return {};
      }
    }
    return {};
  }
  async saveQueueData(queues) {
    const adapter = this.app.vault.adapter;
    try {
      await adapter.write(this.queueFile, JSON.stringify(queues, null, 2));
      Logger.log("Queue data saved.");
    } catch (e) {
      Logger.error("Failed to save queue data:", e);
    }
  }
  // --- ä»»åŠ¡å†…å®¹ç¼“å­˜ (ç”¨äº Agent é—´ä¼ é€’å¤§æ•°æ®) ---
  getCachePath(taskId) {
    const safeName = taskId.replace(/[\\/*?:"<>|]/g, "").trim();
    return `${this.cacheDir}/${safeName}.md`;
  }
  async saveTaskCache(taskId, content) {
    const path = this.getCachePath(taskId);
    try {
      await this.app.vault.adapter.write(path, content);
      Logger.log(`Saved task cache: ${taskId}`);
    } catch (e) {
      Logger.error(`Failed to save task cache for ${taskId}:`, e);
    }
  }
  async loadTaskCache(taskId) {
    const path = this.getCachePath(taskId);
    try {
      if (await this.app.vault.adapter.exists(path)) {
        return await this.app.vault.adapter.read(path);
      }
    } catch (e) {
      Logger.error(`Failed to load task cache for ${taskId}:`, e);
    }
    return "";
  }
  async deleteTaskCache(taskId) {
    const path = this.getCachePath(taskId);
    try {
      if (await this.app.vault.adapter.exists(path)) {
        await this.app.vault.adapter.remove(path);
        Logger.log(`Deleted task cache: ${taskId}`);
      }
    } catch (e) {
      Logger.warn(`Failed to delete task cache for ${taskId}:`, e);
    }
  }
};

// src/core/BaseAgent.ts
var BaseAgent = class {
  constructor(plugin, llm) {
    this.plugin = plugin;
    this.llm = llm;
  }
  get settings() {
    return this.plugin.settings;
  }
  get app() {
    return this.plugin.app;
  }
  // æä¾›ä¾¿æ·çš„æ—¥å¿—æ–¹æ³•
  log(msg) {
    Logger.log(`[${this.constructor.name}] ${msg}`);
  }
  error(msg, ...args) {
    Logger.error(`[${this.constructor.name}] ${msg}`, ...args);
  }
};

// src/agents/GeneratorAgent.ts
var _GeneratorAgent = class extends BaseAgent {
  get queueName() {
    return _GeneratorAgent.QUEUE_NAME;
  }
  async process(item) {
    console.debug(`[GeneratorAgent] æ­£åœ¨å¤„ç†æ¦‚å¿µ: ${item.concept}`);
    const prompt = this.settings.prompt_generator.replace("{concept}", item.concept);
    const content = await this.llm.chat(prompt);
    if (!content || content.trim().length === 0) {
      console.error("[GeneratorAgent] LLM è¿”å›å†…å®¹ä¸ºç©ºã€‚");
      return false;
    }
    const outputDir = this.settings.output_dir;
    const fileName = `${item.concept.replace(/[\\/:"*?<>|]/g, "_")}.md`;
    const filePath = `${outputDir}/${fileName}`;
    const fileExists = await this.app.vault.adapter.exists(filePath);
    if (fileExists) {
      console.warn(`[GeneratorAgent] æ–‡ä»¶å·²å­˜åœ¨ï¼Œè·³è¿‡åˆ›å»º: ${filePath}`);
      return true;
    }
    await this.app.vault.create(filePath, content);
    console.debug(`[GeneratorAgent] å·²æˆåŠŸåˆ›å»ºæ–‡ä»¶: ${filePath}`);
    return true;
  }
};
var GeneratorAgent = _GeneratorAgent;
GeneratorAgent.QUEUE_NAME = "generation_queue";

// src/settings.ts
var import_obsidian4 = require("obsidian");
var OAKSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian4.Setting(containerEl).setName("General").setHeading();
    new import_obsidian4.Setting(containerEl).setName("Debug mode").setDesc("åœ¨æ§åˆ¶å°æ˜¾ç¤ºè¯¦ç»†æ—¥å¿— (æ¨èå¼€å¯ä»¥è§‚å¯Ÿæ•…éšœåˆ‡æ¢)").addToggle((toggle) => toggle.setValue(this.plugin.settings.debug_mode).onChange(async (value) => {
      this.plugin.settings.debug_mode = value;
      Logger.setDebugMode(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Primary Provider").setDesc("é¦–é€‰ AI æä¾›å•†ã€‚å½“å…¶æ‰€æœ‰ Key å‡ä¸å¯ç”¨æ—¶ï¼Œä¼šè‡ªåŠ¨å°è¯•å¦ä¸€ä¸ªã€‚").addDropdown((d) => d.addOption("openai", "OpenAI").addOption("google", "Google").setValue(this.plugin.settings.llmProvider).onChange(async (v) => {
      this.plugin.settings.llmProvider = v;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.llmProvider === "openai") {
      new import_obsidian4.Setting(containerEl).setName("OpenAI Settings").setHeading();
      this.addOpenAISettings(containerEl);
      this.addGoogleSettings(containerEl);
    } else {
      new import_obsidian4.Setting(containerEl).setName("Google Settings").setHeading();
      this.addGoogleSettings(containerEl);
      this.addOpenAISettings(containerEl);
    }
    new import_obsidian4.Setting(containerEl).setName("Engine Settings").setHeading();
    new import_obsidian4.Setting(containerEl).setName("Output Folder").addText((t) => t.setValue(this.plugin.settings.output_dir).onChange(async (v) => {
      this.plugin.settings.output_dir = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Max Retries").addText((t) => t.setValue(String(this.plugin.settings.maxRetries)).onChange(async (v) => {
      this.plugin.settings.maxRetries = parseInt(v);
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Prompt Template").addTextArea((t) => {
      t.setValue(this.plugin.settings.prompt_generator).onChange(async (v) => {
        this.plugin.settings.prompt_generator = v;
        await this.plugin.saveSettings();
      });
      t.inputEl.rows = 5;
      t.inputEl.style.width = "100%";
    });
  }
  addOpenAISettings(el) {
    new import_obsidian4.Setting(el).setName("OpenAI Keys").setDesc("ä¸€è¡Œä¸€ä¸ª Keyã€‚æ”¯æŒè‡ªåŠ¨è½®æ¢å’Œå†·å´ã€‚").addTextArea((t) => {
      t.setValue(this.plugin.settings.openaiApiKey).onChange(async (v) => {
        this.plugin.settings.openaiApiKey = v;
        await this.plugin.saveSettings();
      });
      t.inputEl.rows = 3;
      t.inputEl.style.width = "100%";
    });
    new import_obsidian4.Setting(el).setName("Base URL").addText((t) => t.setValue(this.plugin.settings.openaiBaseUrl).onChange(async (v) => {
      this.plugin.settings.openaiBaseUrl = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(el).setName("Model").addText((t) => t.setValue(this.plugin.settings.openaiModel).onChange(async (v) => {
      this.plugin.settings.openaiModel = v;
      await this.plugin.saveSettings();
    }));
  }
  addGoogleSettings(el) {
    new import_obsidian4.Setting(el).setName("Google Keys").setDesc("ä¸€è¡Œä¸€ä¸ª Keyã€‚").addTextArea((t) => {
      t.setValue(this.plugin.settings.googleApiKey).onChange(async (v) => {
        this.plugin.settings.googleApiKey = v;
        await this.plugin.saveSettings();
      });
      t.inputEl.rows = 3;
      t.inputEl.style.width = "100%";
    });
    new import_obsidian4.Setting(el).setName("Model").addText((t) => t.setValue(this.plugin.settings.googleModel).onChange(async (v) => {
      this.plugin.settings.googleModel = v;
      await this.plugin.saveSettings();
    }));
  }
};

// src/InputModal.ts
var import_obsidian5 = require("obsidian");
var InputModal = class extends import_obsidian5.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "ğŸŒ± æ’­ç§æ–°æ¦‚å¿µ" });
    let inputElement;
    new import_obsidian5.Setting(contentEl).setName("è¾“å…¥æ¦‚å¿µåç§°").setDesc("è¾“å…¥ä½ æƒ³ç”Ÿæˆçš„çŸ¥è¯†ç‚¹ï¼Œä¾‹å¦‚ï¼š'ç¬¬ä¸€æ€§åŸç†'").addText((text) => {
      inputElement = text.inputEl;
      text.onChange((value) => {
        this.result = value;
      });
      text.inputEl.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          this.submit();
        }
      });
    });
    new import_obsidian5.Setting(contentEl).addButton((btn) => btn.setButtonText("æ·»åŠ åˆ°é˜Ÿåˆ—").setCta().onClick(() => {
      this.submit();
    }));
    setTimeout(() => inputElement == null ? void 0 : inputElement.focus(), 0);
  }
  submit() {
    if (this.result && this.result.trim().length > 0) {
      this.close();
      this.onSubmit(this.result.trim());
    } else {
      this.close();
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/core/EventBus.ts
var import_obsidian6 = require("obsidian");
var EventBus = class extends import_obsidian6.Events {
  constructor() {
    super();
  }
  static getInstance() {
    if (!EventBus.instance) {
      EventBus.instance = new EventBus();
    }
    return EventBus.instance;
  }
  // å°è£… emit ä»¥ä¾¿ç»Ÿä¸€è®°å½•æ—¥å¿—
  emit(eventName, ...args) {
    Logger.log(`[EventBus] Emitting: ${eventName}`, args);
    super.trigger(eventName, ...args);
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  llmProvider: "openai",
  openaiApiKey: "",
  openaiBaseUrl: "https://api.openai.com/v1",
  openaiModel: "gpt-3.5-turbo",
  googleApiKey: "",
  googleModel: "gemini-1.5-flash",
  maxRetries: 3,
  prompt_generator: "è¯·è¯¦ç»†è§£é‡Šæ¦‚å¿µ: {concept}ï¼ŒåŒ…å«å®šä¹‰ã€åŸç†å’Œåº”ç”¨ã€‚",
  output_dir: "KnowledgeGraph",
  debug_mode: false
};
var AgentKitPlugin = class extends import_obsidian7.Plugin {
  // --- æ ¸å¿ƒï¼šæš´éœ² API ç»™å…¶ä»–æ’ä»¶ ---
  get api() {
    return {
      version: this.manifest.version,
      registerAgent: (agent) => this.orchestrator.registerAgent(agent),
      // 1. å¼‚æ­¥ä»»åŠ¡è°ƒåº¦
      dispatch: async (queueName, payload, sourcePluginId) => {
        const item = { ...payload, sourcePluginId: sourcePluginId || "External" };
        await this.orchestrator.addToQueue(queueName, item);
        if (!this.orchestrator.isRunning)
          this.orchestrator.start();
        return item.id;
      },
      // 2. [æ–°å¢] åŒæ­¥/å³æ—¶å¯¹è¯æ¥å£
      // ä¾› Lite Chat ç­‰æ’ä»¶ç›´æ¥è°ƒç”¨ï¼Œè·³è¿‡é˜Ÿåˆ—
      chat: async (prompt) => {
        return await this.llm.chat(prompt);
      },
      on: (event, cb) => this.eventBus.on(event, cb),
      off: (event, cb) => this.eventBus.off(event, cb)
    };
  }
  // ------------------------------
  async onload() {
    await this.loadSettings();
    Logger.setDebugMode(this.settings.debug_mode);
    this.persistence = new Persistence(this);
    await this.persistence.init();
    this.queueData = await this.persistence.loadQueueData();
    this.eventBus = EventBus.getInstance();
    if (!await this.app.vault.adapter.exists(this.settings.output_dir)) {
      await this.app.vault.createFolder(this.settings.output_dir);
    }
    this.addSettingTab(new OAKSettingTab(this.app, this));
    this.llm = new LLMProvider(() => this.settings);
    this.orchestrator = new Orchestrator(this);
    this.orchestrator.registerAgent(new GeneratorAgent(this, this.llm));
    this.addCommand({
      id: "add-custom-concept",
      name: "æ·»åŠ æ–°æ¦‚å¿µåˆ°ç”Ÿæˆé˜Ÿåˆ—",
      callback: () => {
        new InputModal(this.app, (concept) => {
          this.api.dispatch(GeneratorAgent.QUEUE_NAME, { concept }, "OAK-GUI").then(() => new import_obsidian7.Notice(`å·²å°† '${concept}' åŠ å…¥é˜Ÿåˆ—ã€‚`));
        }).open();
      }
    });
    this.addCommand({
      id: "toggle-oak",
      name: "å¯åŠ¨/åœæ­¢ OAK å¼•æ“",
      callback: () => {
        if (this.orchestrator.isRunning) {
          this.orchestrator.stop();
        } else {
          this.orchestrator.start();
        }
      }
    });
    this.addRibbonIcon("bot", "OAK: æ·»åŠ æ–°æ¦‚å¿µ", () => {
      new InputModal(this.app, (concept) => {
        this.api.dispatch(GeneratorAgent.QUEUE_NAME, { concept }, "OAK-Ribbon");
      }).open();
    });
    Logger.log("OAK Agent Kit (Framework Mode) loaded.");
  }
  onunload() {
    this.orchestrator.stop();
    Logger.log("OAK Agent Kit unloaded.");
  }
  async loadSettings() {
    const loaded = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loaded);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
