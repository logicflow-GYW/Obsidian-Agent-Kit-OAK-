/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
If you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AgentKitPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/core/Orchestrator.ts
var import_obsidian4 = require("obsidian");

// src/core/EventBus.ts
var import_obsidian2 = require("obsidian");

// src/core/utils.ts
var import_obsidian = require("obsidian");
var _Logger = class {
  // å†…å­˜ä¸­æœ€å¤šä¿å­˜200æ¡æ—¥å¿—
  static setDebugMode(debug) {
    _Logger.isDebug = debug;
  }
  static formatMessage(level, namespace, message) {
    return {
      timestamp: new Date().toISOString(),
      level,
      namespace,
      message
    };
  }
  static output(entry, ...args) {
    const logString = JSON.stringify(entry, null, 2);
    if (entry.level === "ERROR") {
      console.error(logString, ...args);
    } else if (entry.level === "WARN") {
      console.warn(logString, ...args);
    } else {
      if (_Logger.isDebug) {
        console.log(logString, ...args);
      }
    }
    _Logger.memoryBuffer.push(entry);
    if (_Logger.memoryBuffer.length > _Logger.MAX_MEMORY_LOGS) {
      _Logger.memoryBuffer.shift();
    }
  }
  static log(message, details) {
    var _a;
    const namespace = ((_a = message.match(/^\[(.*?)\]/)) == null ? void 0 : _a[1]) || "OAK";
    const cleanMessage = message.replace(/^\[.*?\]\s*/, "");
    const entry = _Logger.formatMessage("INFO", namespace, cleanMessage);
    if (details) {
      entry.details = details;
    }
    _Logger.output(entry);
  }
  static warn(message, details) {
    var _a;
    const namespace = ((_a = message.match(/^\[(.*?)\]/)) == null ? void 0 : _a[1]) || "OAK";
    const cleanMessage = message.replace(/^\[.*?\]\s*/, "");
    const entry = _Logger.formatMessage("WARN", namespace, cleanMessage);
    if (details) {
      entry.details = details;
    }
    _Logger.output(entry);
  }
  static error(message, error, details) {
    var _a;
    const namespace = ((_a = message.match(/^\[(.*?)\]/)) == null ? void 0 : _a[1]) || "OAK";
    const cleanMessage = message.replace(/^\[.*?\]\s*/, "");
    const entry = _Logger.formatMessage("ERROR", namespace, cleanMessage);
    if (error instanceof Error) {
      entry.details = { ...details, error: error.message, stack: error.stack };
    } else if (error) {
      entry.details = { ...details, error: String(error) };
    } else if (details) {
      entry.details = details;
    }
    _Logger.output(entry);
  }
  // ã€æ–°å¢ã€‘é™æ€æ–¹æ³•ï¼Œä¾›å¤–éƒ¨è·å–å†…å­˜ä¸­çš„æ—¥å¿—
  static getMemoryLogs() {
    return [..._Logger.memoryBuffer];
  }
};
var Logger = _Logger;
Logger.isDebug = false;
Logger.memoryBuffer = [];
Logger.MAX_MEMORY_LOGS = 200;
async function ensureFolderExists(app, folderPath) {
  const normalizedPath = (0, import_obsidian.normalizePath)(folderPath);
  const folders = normalizedPath.split("/");
  let currentPath = "";
  for (const folder of folders) {
    currentPath = currentPath === "" ? folder : `${currentPath}/${folder}`;
    const existing = app.vault.getAbstractFileByPath(currentPath);
    if (!existing) {
      try {
        await app.vault.createFolder(currentPath);
      } catch (error) {
      }
    } else if (!(existing instanceof import_obsidian.TFolder)) {
      throw new Error(`Path conflict: ${currentPath} exists but is not a folder.`);
    }
  }
}

// src/core/EventBus.ts
var EventBus = class extends import_obsidian2.Events {
  constructor() {
    super();
  }
  static getInstance() {
    if (!EventBus.instance) {
      EventBus.instance = new EventBus();
    }
    return EventBus.instance;
  }
  // å°è£… emit ä»¥ä¾¿ç»Ÿä¸€è®°å½•æ—¥å¿—
  emit(eventName, ...args) {
    Logger.log(`[EventBus] Emitting: ${eventName}`, args);
    super.trigger(eventName, ...args);
  }
};
var OakEvents = {
  TASK_ADDED: "oak:task-added",
  TASK_STARTED: "oak:task-started",
  TASK_COMPLETED: "oak:task-completed",
  // æˆåŠŸ
  TASK_FAILED: "oak:task-failed",
  // å¤±è´¥ï¼ˆå¯èƒ½é‡è¯•ï¼‰
  TASK_DISCARDED: "oak:task-discarded",
  // å½»åº•æ”¾å¼ƒ
  WORKFLOW_COMPLETE: "oak:workflow-complete"
};

// src/core/LLMProvider.ts
var import_obsidian3 = require("obsidian");
var AllModelsFailedError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "AllModelsFailedError";
  }
};
var LLMProvider = class {
  constructor(getSettings) {
    this.getSettings = getSettings;
    this.keyUsageOpenAI = /* @__PURE__ */ new Map();
    this.keyUsageGoogle = /* @__PURE__ */ new Map();
    this.COOLDOWN_SECONDS = 300;
    // ã€æ–°å¢ã€‘é»˜è®¤è¶…æ—¶ 90 ç§’
    this.REQUEST_TIMEOUT_MS = 9e4;
    this.openAIKeyIndex = 0;
    this.googleKeyIndex = 0;
  }
  async chat(prompt) {
    const settings = this.getSettings();
    const provider = settings.llmProvider;
    try {
      if (provider === "openai") {
        return await this.tryOpenAIFirst(prompt);
      } else {
        return await this.tryGoogleFirst(prompt);
      }
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      Logger.error("[LLM Fatal Error]", error);
      if (error instanceof AllModelsFailedError) {
        throw error;
      }
      new import_obsidian3.Notice(`AI å“åº”å¤±è´¥: ${msg}`);
      return "";
    }
  }
  // ã€æ–°å¢ã€‘å¸¦è¶…æ—¶çš„è¯·æ±‚åŒ…è£…å™¨
  async _requestWithTimeout(requestParams) {
    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        reject(new Error(`API Request timed out after ${this.REQUEST_TIMEOUT_MS / 1e3}s`));
      }, this.REQUEST_TIMEOUT_MS);
      (0, import_obsidian3.requestUrl)(requestParams).then((response) => {
        clearTimeout(timer);
        resolve(response);
      }).catch((err) => {
        clearTimeout(timer);
        reject(err);
      });
    });
  }
  async tryOpenAIFirst(prompt) {
    try {
      return await this.callOpenAI(prompt);
    } catch (e) {
      Logger.warn("OpenAI failed, attempting failover to Google...", e);
      if (this.getKeys(this.getSettings().googleApiKey).length > 0) {
        new import_obsidian3.Notice("OpenAI æš‚æ—¶ä¸å¯ç”¨ï¼Œæ­£åœ¨åˆ‡æ¢è‡³ Google...");
        return await this.callGoogle(prompt);
      }
      throw new AllModelsFailedError("OpenAI failed and no Google keys available.");
    }
  }
  async tryGoogleFirst(prompt) {
    try {
      return await this.callGoogle(prompt);
    } catch (e) {
      Logger.warn("Google failed, attempting failover to OpenAI...", e);
      if (this.getKeys(this.getSettings().openaiApiKey).length > 0) {
        new import_obsidian3.Notice("Google æš‚æ—¶ä¸å¯ç”¨ï¼Œæ­£åœ¨åˆ‡æ¢è‡³ OpenAI...");
        return await this.callOpenAI(prompt);
      }
      throw new AllModelsFailedError("Google failed and no OpenAI keys available.");
    }
  }
  async callOpenAI(prompt) {
    const settings = this.getSettings();
    const keys = this.getPrioritizedKeys(settings.openaiApiKey, "openai");
    if (keys.length === 0)
      throw new AllModelsFailedError("OpenAI API Keys exhausted or not configured.");
    let lastError = null;
    for (const apiKey of keys) {
      try {
        Logger.log(`Trying OpenAI Key: ...${apiKey.slice(-4)}`);
        const result = await this._requestOpenAI(apiKey, settings, prompt);
        this.resetCooldown(apiKey, "openai");
        this.updateKeyIndexAfterSuccess(apiKey, settings.openaiApiKey, "openai");
        return result;
      } catch (error) {
        Logger.warn(`OpenAI Key ...${apiKey.slice(-4)} failed: ${error.message}`);
        lastError = error;
        if (this.isQuotaError(error)) {
          this.applyCooldown(apiKey, "openai");
        }
      }
    }
    throw new AllModelsFailedError(`All OpenAI keys failed. Last error: ${lastError == null ? void 0 : lastError.message}`);
  }
  async callGoogle(prompt) {
    const settings = this.getSettings();
    const keys = this.getPrioritizedKeys(settings.googleApiKey, "google");
    if (keys.length === 0)
      throw new AllModelsFailedError("Google API Keys exhausted or not configured.");
    let lastError = null;
    for (const apiKey of keys) {
      try {
        Logger.log(`Trying Google Key: ...${apiKey.slice(-4)}`);
        const result = await this._requestGoogle(apiKey, settings, prompt);
        this.resetCooldown(apiKey, "google");
        this.updateKeyIndexAfterSuccess(apiKey, settings.googleApiKey, "google");
        return result;
      } catch (error) {
        Logger.warn(`Google Key ...${apiKey.slice(-4)} failed: ${error.message}`);
        lastError = error;
        if (this.isQuotaError(error)) {
          this.applyCooldown(apiKey, "google");
        }
      }
    }
    throw new AllModelsFailedError(`All Google keys failed. Last error: ${lastError == null ? void 0 : lastError.message}`);
  }
  async _requestOpenAI(apiKey, settings, prompt) {
    const url = `${settings.openaiBaseUrl.replace(/\/$/, "")}/chat/completions`;
    const response = await this._requestWithTimeout({
      url,
      method: "POST",
      headers: { "Content-Type": "application/json", "Authorization": `Bearer ${apiKey}` },
      body: JSON.stringify({
        model: settings.openaiModel,
        messages: [{ role: "user", content: prompt }],
        temperature: 0.7
      })
    });
    if (response.status >= 400)
      throw new Error(`OpenAI Status ${response.status}`);
    return response.json.choices[0].message.content.trim();
  }
  async _requestGoogle(apiKey, settings, prompt) {
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${settings.googleModel}:generateContent?key=${apiKey}`;
    const response = await this._requestWithTimeout({
      url,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
    });
    if (response.status >= 400)
      throw new Error(`Google Status ${response.status}`);
    if (response.json.candidates && response.json.candidates.length > 0) {
      return response.json.candidates[0].content.parts[0].text.trim();
    }
    return "";
  }
  getKeys(keyString) {
    if (!keyString)
      return [];
    return keyString.split("\n").map((k) => k.trim()).filter((k) => k.length > 0);
  }
  getPrioritizedKeys(keyString, provider) {
    const allKeys = this.getKeys(keyString);
    if (allKeys.length === 0)
      return [];
    const strategy = this.getSettings().apiKeyStrategy;
    let orderedKeys = [...allKeys];
    if (strategy === "round-robin") {
      const currentIndex = provider === "openai" ? this.openAIKeyIndex : this.googleKeyIndex;
      const safeIndex = currentIndex % allKeys.length;
      orderedKeys = [
        ...allKeys.slice(safeIndex),
        ...allKeys.slice(0, safeIndex)
      ];
    }
    const map = provider === "openai" ? this.keyUsageOpenAI : this.keyUsageGoogle;
    const now = Date.now() / 1e3;
    return orderedKeys.filter((key) => {
      const usage = map.get(key);
      if (!usage)
        return true;
      return now >= usage.cooldown_until;
    });
  }
  updateKeyIndexAfterSuccess(usedKey, keyString, provider) {
    if (this.getSettings().apiKeyStrategy !== "round-robin")
      return;
    const allKeys = this.getKeys(keyString);
    const index = allKeys.indexOf(usedKey);
    if (index !== -1) {
      const nextIndex = (index + 1) % allKeys.length;
      if (provider === "openai") {
        this.openAIKeyIndex = nextIndex;
      } else {
        this.googleKeyIndex = nextIndex;
      }
      Logger.log(`[Round-Robin] Strategy rotated. Next start index for ${provider}: ${nextIndex}`);
    }
  }
  isQuotaError(error) {
    const msg = (error.message || "").toLowerCase();
    if (msg.includes("429") || msg.includes("401") || msg.includes("403"))
      return true;
    if (msg.includes("quota") || msg.includes("rate limit") || msg.includes("insufficient"))
      return true;
    return false;
  }
  applyCooldown(key, provider) {
    const map = provider === "openai" ? this.keyUsageOpenAI : this.keyUsageGoogle;
    map.set(key, { cooldown_until: Date.now() / 1e3 + this.COOLDOWN_SECONDS });
    Logger.warn(`â„ï¸ Key ...${key.slice(-4)} å†·å´ 5 åˆ†é’Ÿ.`);
  }
  resetCooldown(key, provider) {
    const map = provider === "openai" ? this.keyUsageOpenAI : this.keyUsageGoogle;
    map.delete(key);
  }
};

// src/core/Orchestrator.ts
var Orchestrator = class {
  constructor(dependencies) {
    this._isRunning = false;
    this.agents = [];
    this.queueData = {};
    this.activeTasks = /* @__PURE__ */ new Map();
    this.TASK_TIMEOUT_MS = 5 * 60 * 1e3;
    this.dependencies = dependencies;
  }
  get isRunning() {
    return this._isRunning;
  }
  registerAgent(agent) {
    this.agents.push(agent);
    if (!this.queueData[agent.queueName]) {
      this.queueData[agent.queueName] = {};
    }
    Logger.log(`Registered Agent: ${agent.constructor.name} -> Queue: ${agent.queueName}`);
  }
  async loadInitialQueueData() {
    this.queueData = await this.dependencies.persistence.loadQueueData();
  }
  async addToQueue(queueName, item) {
    const id = Date.now().toString() + "-" + Math.random().toString(36).substr(2, 9);
    const fullItem = {
      id,
      status: "queued" /* QUEUED */,
      retries: 0,
      ...item
    };
    if (!this.queueData[queueName]) {
      this.queueData[queueName] = {};
    }
    this.queueData[queueName][id] = fullItem;
    await this.dependencies.persistence.saveQueueData(this.queueData);
    this.dependencies.eventBus.emit(OakEvents.TASK_ADDED, { taskId: id, queueName, payload: item });
    Logger.log(`Task added to ${queueName}: ${id}`);
    return id;
  }
  start() {
    if (this._isRunning)
      return;
    this._isRunning = true;
    new import_obsidian4.Notice("ğŸš€ OAK å¼•æ“å·²å¯åŠ¨");
    Logger.log("Engine started");
    this.loop().catch((err) => Logger.error("Loop error:", err));
  }
  stop() {
    this._isRunning = false;
    new import_obsidian4.Notice("ğŸ›‘ OAK å¼•æ“å·²åœæ­¢");
    Logger.log("Engine stopped");
  }
  cleanupZombieTasks() {
    const now = Date.now();
    for (const [taskId, startTime] of this.activeTasks.entries()) {
      if (now - startTime > this.TASK_TIMEOUT_MS) {
        Logger.warn(`ğŸ§¹ [Zombie Sweeper] Task '${taskId}' timed out. Re-queuing.`);
        this.activeTasks.delete(taskId);
        const item = this.findTaskItemById(taskId);
        if (item) {
          item.status = "failed" /* FAILED */;
          item.retries++;
        }
      }
    }
  }
  // è¾…åŠ©å‡½æ•°ï¼šæ ¹æ®IDæŸ¥æ‰¾ä»»åŠ¡é¡¹
  findTaskItemById(taskId) {
    for (const queueName in this.queueData) {
      if (this.queueData[queueName][taskId]) {
        return { item: this.queueData[queueName][taskId], queueName };
      }
    }
    return null;
  }
  async loop() {
    if (!this._isRunning)
      return;
    this.cleanupZombieTasks();
    const maxConcurrency = this.dependencies.getSettings().concurrency || 3;
    let slotsAvailable = maxConcurrency - this.activeTasks.size;
    if (slotsAvailable > 0) {
      for (const agent of this.agents) {
        if (slotsAvailable <= 0 || !this._isRunning)
          break;
        const queueName = agent.queueName;
        const queue = this.queueData[queueName];
        if (!queue)
          continue;
        const nextTaskId = Object.keys(queue).find((id) => queue[id].status === "queued" /* QUEUED */);
        if (nextTaskId) {
          const item = queue[nextTaskId];
          item.status = "running" /* RUNNING */;
          this.activeTasks.set(nextTaskId, Date.now());
          slotsAvailable--;
          await this.dependencies.persistence.saveQueueData(this.queueData);
          this.dependencies.eventBus.emit(OakEvents.TASK_STARTED, { taskId: nextTaskId, agent: agent.constructor.name, queueName });
          this.processTask(agent, item).catch((err) => {
            Logger.error(`Unhandled error in processTask for ${nextTaskId}`, err);
            if (this.activeTasks.has(nextTaskId)) {
              this.activeTasks.delete(nextTaskId);
              const failedItem = this.findTaskItemById(nextTaskId);
              if (failedItem) {
                failedItem.item.status = "failed" /* FAILED */;
                failedItem.item.retries++;
              }
            }
          });
        }
      }
    }
    const delay = this.activeTasks.size > 0 ? 1e3 : 3e3;
    if (this._isRunning) {
      setTimeout(() => this.loop().catch((err) => Logger.error("Loop timeout error:", err)), delay);
    }
  }
  async processTask(agent, item) {
    const taskId = item.id;
    const queueName = agent.queueName;
    let taskSucceeded = false;
    try {
      Logger.log(`Processing task ${taskId} in ${queueName}...`);
      const updatedItem = await agent.process(item);
      this.queueData[queueName][taskId] = { ...updatedItem, status: "success" /* SUCCESS */ };
      taskSucceeded = true;
      await this.dependencies.persistence.deleteTaskCache(taskId);
      Logger.log(`âœ… Task ${taskId} completed.`);
      this.dependencies.eventBus.emit(OakEvents.TASK_COMPLETED, { taskId, queueName });
    } catch (error) {
      Logger.error(`Agent ${agent.constructor.name} failed task ${taskId}:`, error);
      if (error instanceof AllModelsFailedError) {
        Logger.error(`ğŸ›‘ Engine paused due to fatal error: ${error.message}`);
        new import_obsidian4.Notice(`å¼•æ“ç´§æ€¥æš‚åœ: æ‰€æœ‰ API Key å‡ä¸å¯ç”¨ã€‚`);
        this.stop();
        this.activeTasks.delete(taskId);
        this.queueData[queueName][taskId].status = "failed" /* FAILED */;
        await this.dependencies.persistence.saveQueueData(this.queueData);
        return;
      }
      const itemToUpdate = this.queueData[queueName][taskId];
      itemToUpdate.retries++;
      const maxRetries = this.dependencies.getSettings().maxRetries || 3;
      if (itemToUpdate.retries < maxRetries) {
        Logger.warn(`Task ${taskId} retrying (${itemToUpdate.retries}/${maxRetries})`);
        itemToUpdate.status = "queued" /* QUEUED */;
        this.dependencies.eventBus.emit(OakEvents.TASK_FAILED, { taskId, queueName, error: error.message, willRetry: true });
      } else {
        Logger.error(`Task ${taskId} max retries reached. Discarding.`);
        itemToUpdate.status = "discarded" /* DISCARDED */;
        taskSucceeded = true;
        new import_obsidian4.Notice(`ä»»åŠ¡ ${taskId} å·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œå·²è¢«ä¸¢å¼ƒã€‚`);
        await this.dependencies.persistence.deleteTaskCache(taskId);
        this.dependencies.eventBus.emit(OakEvents.TASK_DISCARDED, { taskId, queueName, error: error.message });
      }
    } finally {
      this.activeTasks.delete(taskId);
      if (taskSucceeded) {
        delete this.queueData[queueName][taskId];
        if (Object.keys(this.queueData[queueName]).length === 0) {
          delete this.queueData[queueName];
        }
        await this.dependencies.persistence.saveQueueData(this.queueData, { clean: true });
      } else {
        await this.dependencies.persistence.saveQueueData(this.queueData);
      }
    }
  }
};

// src/core/Persistence.ts
var import_obsidian5 = require("obsidian");
var Persistence = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = plugin.app;
    this.cacheDir = (0, import_obsidian5.normalizePath)(`${this.app.vault.configDir}/plugins/${this.plugin.manifest.id}/task_cache`);
    this.queueFile = (0, import_obsidian5.normalizePath)(`${this.app.vault.configDir}/plugins/${this.plugin.manifest.id}/queues.json`);
  }
  async init() {
    const adapter = this.app.vault.adapter;
    if (!await adapter.exists(this.cacheDir)) {
      await adapter.mkdir(this.cacheDir);
    }
  }
  async loadQueueData() {
    const adapter = this.app.vault.adapter;
    if (await adapter.exists(this.queueFile)) {
      try {
        const content = await adapter.read(this.queueFile);
        const data = JSON.parse(content);
        if (Array.isArray(data)) {
          Logger.warn("[Persistence] Detected old queue format (array). Attempting conversion...");
        }
        return data;
      } catch (e) {
        Logger.error("Failed to load queue data:", e);
        return {};
      }
    }
    return {};
  }
  // ã€ä¿®æ”¹ã€‘saveQueueData æ–¹æ³•
  async saveQueueData(queues, options) {
    let dataToSave = queues;
    if (options == null ? void 0 : options.clean) {
      dataToSave = this.cleanQueueData(queues);
    }
    const adapter = this.app.vault.adapter;
    try {
      await adapter.write(this.queueFile, JSON.stringify(dataToSave, null, 2));
      Logger.log("Queue data saved.");
    } catch (e) {
      Logger.error("Failed to save queue data:", e);
    }
  }
  // ã€æ–°å¢ã€‘è¾…åŠ©æ–¹æ³•ï¼šæ¸…ç†å·²å®Œæˆçš„ä»»åŠ¡
  cleanQueueData(rawQueueData) {
    const cleanedData = {};
    for (const queueName in rawQueueData) {
      const tasks = rawQueueData[queueName];
      const activeTasks = {};
      for (const taskId in tasks) {
        const task = tasks[taskId];
        if (task.status !== "success" /* SUCCESS */ && task.status !== "discarded" /* DISCARDED */) {
          activeTasks[taskId] = task;
        }
      }
      if (Object.keys(activeTasks).length > 0) {
        cleanedData[queueName] = activeTasks;
      }
    }
    return cleanedData;
  }
  // ... task cache methods remain the same ...
  getCachePath(taskId) {
    const safeName = taskId.replace(/[\\/*?:"<>|]/g, "").trim();
    return `${this.cacheDir}/${safeName}.md`;
  }
  async saveTaskCache(taskId, content) {
    const path = this.getCachePath(taskId);
    try {
      await this.app.vault.adapter.write(path, content);
      Logger.log(`Saved task cache: ${taskId}`);
    } catch (e) {
      Logger.error(`Failed to save task cache for ${taskId}:`, e);
    }
  }
  async loadTaskCache(taskId) {
    const path = this.getCachePath(taskId);
    try {
      if (await this.app.vault.adapter.exists(path)) {
        return await this.app.vault.adapter.read(path);
      }
    } catch (e) {
      Logger.error(`Failed to load task cache for ${taskId}:`, e);
    }
    return "";
  }
  async deleteTaskCache(taskId) {
    const path = this.getCachePath(taskId);
    try {
      if (await this.app.vault.adapter.exists(path)) {
        await this.app.vault.adapter.remove(path);
        Logger.log(`Deleted task cache: ${taskId}`);
      }
    } catch (e) {
      Logger.warn(`Failed to delete task cache for ${taskId}:`, e);
    }
  }
};

// src/core/BaseAgent.ts
var BaseAgent = class {
  constructor(context, llm) {
    this.context = context;
    this.llm = llm;
  }
  // é€šè¿‡ context çš„ getter è®¿é—®è®¾ç½®ï¼Œè€Œä¸æ˜¯ç›´æ¥è®¿é—® plugin.settings
  get settings() {
    return this.context.settings;
  }
  get app() {
    return this.context.app;
  }
  // æä¾›ä¾¿æ·çš„æ—¥å¿—æ–¹æ³•
  log(msg) {
    Logger.log(`[${this.constructor.name}] ${msg}`);
  }
  error(msg, ...args) {
    Logger.error(`[${this.constructor.name}] ${msg}`, ...args);
  }
  // æä¾›ä¾¿æ·çš„äº‹ä»¶è§¦å‘æ–¹æ³•
  emit(eventName, data) {
    this.context.triggerEvent(eventName, data);
  }
  // æä¾›ä¾¿æ·çš„ç¼“å­˜æ“ä½œæ–¹æ³•
  async saveTaskCache(taskId, content) {
    await this.context.persistence.saveTaskCache(taskId, content);
  }
  async loadTaskCache(taskId) {
    return await this.context.persistence.loadTaskCache(taskId);
  }
  async deleteTaskCache(taskId) {
    await this.context.persistence.deleteTaskCache(taskId);
  }
};

// src/agents/GeneratorAgent.ts
var _GeneratorAgent = class extends BaseAgent {
  get queueName() {
    return _GeneratorAgent.QUEUE_NAME;
  }
  // ã€ä¿®æ”¹ã€‘process æ–¹æ³•ç°åœ¨è¿”å›æ›´æ–°åçš„ TaskItem
  async process(item) {
    this.log(`æ­£åœ¨å¤„ç†æ¦‚å¿µ: ${item.concept}`);
    const prompt = this.settings.prompt_generator.replace("{concept}", item.concept);
    const content = await this.llm.chat(prompt);
    if (!content || content.trim().length === 0) {
      this.error("LLM è¿”å›å†…å®¹ä¸ºç©ºã€‚");
      throw new Error("LLM returned empty content.");
    }
    const outputDir = this.settings.output_dir;
    try {
      await ensureFolderExists(this.app, outputDir);
    } catch (e) {
      this.error(`åˆ›å»ºæ–‡ä»¶å¤¹å¤±è´¥: ${outputDir}`, e);
      throw new Error(`Failed to create output directory: ${outputDir}`);
    }
    const fileName = `${item.concept.replace(/[\\/:"*?<>|]/g, "_")}.md`;
    const filePath = `${outputDir}/${fileName}`;
    const fileExists = await this.app.vault.adapter.exists(filePath);
    if (fileExists) {
      this.log(`æ–‡ä»¶å·²å­˜åœ¨ï¼Œè·³è¿‡åˆ›å»º: ${filePath}`);
      return { ...item, status: "success" /* SUCCESS */ };
    }
    await this.app.vault.create(filePath, content);
    this.log(`å·²æˆåŠŸåˆ›å»ºæ–‡ä»¶: ${filePath}`);
    return { ...item, status: "success" /* SUCCESS */ };
  }
};
var GeneratorAgent = _GeneratorAgent;
GeneratorAgent.QUEUE_NAME = "generation_queue";

// src/settings.ts
var import_obsidian6 = require("obsidian");
var LogViewerModal = class extends import_obsidian6.Modal {
  constructor(app) {
    super(app);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "OAK Recent Logs" });
    const logs = Logger.getMemoryLogs();
    if (logs.length === 0) {
      contentEl.createEl("p", { text: "No recent logs to display." });
      return;
    }
    const logContainer = contentEl.createDiv("oak-log-viewer-container");
    logContainer.style.height = "400px";
    logContainer.style.overflow = "auto";
    logContainer.style.border = "1px solid var(--background-modifier-border)";
    logContainer.style.padding = "10px";
    logContainer.style.backgroundColor = "var(--background-secondary)";
    logContainer.style.fontFamily = "monospace";
    logContainer.style.fontSize = "0.8em";
    logContainer.style.whiteSpace = "pre-wrap";
    const logText = logs.map((entry) => {
      const levelColor = entry.level === "ERROR" ? "var(--text-error)" : entry.level === "WARN" ? "var(--text-warning)" : "var(--text-normal)";
      return `<span style="color: var(--text-muted);">[${entry.timestamp}]</span> <span style="color: ${levelColor}; font-weight: bold;">[${entry.level}]</span> <span style="color: var(--text-accent);">[${entry.namespace}]</span> ${entry.message}${entry.details ? `
  ${JSON.stringify(entry.details, null, 2)}` : ""}`;
    }).join("\n\n");
    logContainer.innerHTML = logText;
    const copyButton = contentEl.createEl("button", { text: "Copy Logs to Clipboard" });
    copyButton.onclick = async () => {
      const rawLogText = logs.map((entry) => JSON.stringify(entry)).join("\n");
      await navigator.clipboard.writeText(rawLogText);
      new import_obsidian6.Notice("Logs copied to clipboard!");
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var OAKSettingTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian6.Setting(containerEl).setName("General").setHeading();
    new import_obsidian6.Setting(containerEl).setName("Debug mode").setDesc("åœ¨æ§åˆ¶å°æ˜¾ç¤ºè¯¦ç»†æ—¥å¿—ã€‚å¿…é¡»å¼€å¯æ­¤æ¨¡å¼æ‰èƒ½è®°å½• INFO çº§åˆ«æ—¥å¿—ã€‚").addToggle((toggle) => toggle.setValue(this.plugin.settings.debug_mode).onChange(async (value) => {
      this.plugin.settings.debug_mode = value;
      Logger.setDebugMode(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Primary Provider").setDesc("é¦–é€‰ AI æä¾›å•†ã€‚").addDropdown((d) => d.addOption("openai", "OpenAI").addOption("google", "Google").setValue(this.plugin.settings.llmProvider).onChange(async (v) => {
      this.plugin.settings.llmProvider = v;
      await this.plugin.saveSettings();
      this.display();
    }));
    new import_obsidian6.Setting(containerEl).setName("API Key Strategy").setDesc("é€‰æ‹© API Key çš„è½®æ¢æ–¹å¼ã€‚").addDropdown((d) => d.addOption("exhaustion", "é¡ºåºè€—å°½").addOption("round-robin", "è½®è¯¢å‡è¡¡").setValue(this.plugin.settings.apiKeyStrategy).onChange(async (v) => {
      this.plugin.settings.apiKeyStrategy = v;
      await this.plugin.saveSettings();
    }));
    const isPrimaryOpenAI = this.plugin.settings.llmProvider === "openai";
    if (isPrimaryOpenAI) {
      this.addOpenAISettings(containerEl);
      this.addGoogleSettings(containerEl);
    } else {
      this.addGoogleSettings(containerEl);
      this.addOpenAISettings(containerEl);
    }
    new import_obsidian6.Setting(containerEl).setName("Engine Settings").setHeading();
    new import_obsidian6.Setting(containerEl).setName("Max Concurrency").setDesc("åŒæ—¶å¤„ç†çš„ä»»åŠ¡æ•°é‡ (æ»‘åŠ¨çª—å£å¤§å°)ã€‚å»ºè®®è®¾ç½®ä¸º 3-5ã€‚").addSlider((slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.concurrency || 3).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.concurrency = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Max Retries").setDesc("ä»»åŠ¡å¤±è´¥åçš„æœ€å¤§é‡è¯•æ¬¡æ•°ã€‚").addText((text) => text.setPlaceholder("3").setValue(String(this.plugin.settings.maxRetries)).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.maxRetries = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian6.Setting(containerEl).setName("Output Folder").setDesc("ç”Ÿæˆæ–‡ä»¶çš„é»˜è®¤å­˜æ”¾è·¯å¾„ã€‚").addText((text) => text.setPlaceholder("KnowledgeGraph").setValue(this.plugin.settings.output_dir).onChange(async (value) => {
      this.plugin.settings.output_dir = value || "KnowledgeGraph";
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Prompt Template (for GeneratorAgent)").setDesc("ç”¨äºç”Ÿæˆå†…å®¹çš„æç¤ºè¯æ¨¡æ¿ï¼Œä½¿ç”¨ {concept} ä½œä¸ºå ä½ç¬¦ã€‚").addTextArea((text) => {
      text.setValue(this.plugin.settings.prompt_generator).onChange(async (value) => {
        this.plugin.settings.prompt_generator = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 5;
      text.inputEl.style.width = "100%";
      text.inputEl.style.fontFamily = "monospace";
    });
    new import_obsidian6.Setting(containerEl).setName("Diagnostics").setHeading();
    new import_obsidian6.Setting(containerEl).setName("View Logs").setDesc("æ‰“å¼€ä¸€ä¸ªçª—å£ï¼Œæ˜¾ç¤ºæœ€è¿‘åœ¨å†…å­˜ä¸­è®°å½•çš„ OAK æ—¥å¿—ã€‚").addButton(
      (button) => button.setButtonText("Open Log Viewer").onClick(() => {
        new LogViewerModal(this.app).open();
      })
    );
    containerEl.createEl("p", {
      text: "Note: Logs are only kept in memory temporarily. For permanent storage, please check the browser's developer console.",
      cls: "setting-item-description"
    });
  }
  addOpenAISettings(el) {
    new import_obsidian6.Setting(el).setName("OpenAI Settings").setHeading();
    new import_obsidian6.Setting(el).setName("OpenAI Keys").setDesc("ä¸€è¡Œä¸€ä¸ª Keyã€‚").addTextArea((t) => {
      t.setValue(this.plugin.settings.openaiApiKey).onChange(async (v) => {
        this.plugin.settings.openaiApiKey = v;
        await this.plugin.saveSettings();
      });
      t.inputEl.rows = 3;
      t.inputEl.style.width = "100%";
      t.inputEl.style.fontFamily = "monospace";
    });
    new import_obsidian6.Setting(el).setName("Base URL").setDesc("API è¯·æ±‚åœ°å€ï¼Œç”¨äºå…¼å®¹ OpenAI æ ¼å¼çš„ä»£ç†æœåŠ¡ã€‚").addText((t) => t.setPlaceholder("https://api.openai.com/v1").setValue(this.plugin.settings.openaiBaseUrl).onChange(async (v) => {
      this.plugin.settings.openaiBaseUrl = v || "https://api.openai.com/v1";
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(el).setName("Model").setDesc("è¦ä½¿ç”¨çš„ OpenAI æ¨¡å‹ã€‚").addText((t) => t.setPlaceholder("gpt-3.5-turbo").setValue(this.plugin.settings.openaiModel).onChange(async (v) => {
      this.plugin.settings.openaiModel = v || "gpt-3.5-turbo";
      await this.plugin.saveSettings();
    }));
  }
  addGoogleSettings(el) {
    new import_obsidian6.Setting(el).setName("Google Settings").setHeading();
    new import_obsidian6.Setting(el).setName("Google Keys").setDesc("ä¸€è¡Œä¸€ä¸ª Keyã€‚").addTextArea((t) => {
      t.setValue(this.plugin.settings.googleApiKey).onChange(async (v) => {
        this.plugin.settings.googleApiKey = v;
        await this.plugin.saveSettings();
      });
      t.inputEl.rows = 3;
      t.inputEl.style.width = "100%";
      t.inputEl.style.fontFamily = "monospace";
    });
    new import_obsidian6.Setting(el).setName("Model").setDesc("è¦ä½¿ç”¨çš„ Google æ¨¡å‹ã€‚").addText((t) => t.setPlaceholder("gemini-1.5-flash").setValue(this.plugin.settings.googleModel).onChange(async (v) => {
      this.plugin.settings.googleModel = v || "gemini-1.5-flash";
      await this.plugin.saveSettings();
    }));
  }
};

// src/InputModal.ts
var import_obsidian7 = require("obsidian");
var InputModal = class extends import_obsidian7.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "ğŸŒ± æ’­ç§æ–°æ¦‚å¿µ" });
    let inputElement;
    new import_obsidian7.Setting(contentEl).setName("è¾“å…¥æ¦‚å¿µåç§°").setDesc("è¾“å…¥ä½ æƒ³ç”Ÿæˆçš„çŸ¥è¯†ç‚¹ï¼Œä¾‹å¦‚ï¼š'ç¬¬ä¸€æ€§åŸç†'").addText((text) => {
      inputElement = text.inputEl;
      text.onChange((value) => {
        this.result = value;
      });
      text.inputEl.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          this.submit();
        }
      });
    });
    new import_obsidian7.Setting(contentEl).addButton((btn) => btn.setButtonText("æ·»åŠ åˆ°é˜Ÿåˆ—").setCta().onClick(() => {
      this.submit();
    }));
    setTimeout(() => inputElement == null ? void 0 : inputElement.focus(), 0);
  }
  submit() {
    if (this.result && this.result.trim().length > 0) {
      this.close();
      this.onSubmit(this.result.trim());
    } else {
      this.close();
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  llmProvider: "openai",
  apiKeyStrategy: "exhaustion",
  openaiApiKey: "",
  openaiBaseUrl: "https://api.openai.com/v1",
  openaiModel: "gpt-3.5-turbo",
  googleApiKey: "",
  googleModel: "gemini-1.5-flash",
  maxRetries: 3,
  concurrency: 3,
  prompt_generator: "è¯·è¯¦ç»†è§£é‡Šæ¦‚å¿µ: {concept}ï¼ŒåŒ…å«å®šä¹‰ã€åŸç†å’Œåº”ç”¨ã€‚",
  output_dir: "KnowledgeGraph",
  debug_mode: false
};
var AgentKitPlugin = class extends import_obsidian8.Plugin {
  async onload() {
    await this.loadSettings();
    Logger.setDebugMode(this.settings.debug_mode);
    this.persistence = new Persistence(this);
    await this.persistence.init();
    this.eventBus = EventBus.getInstance();
    this.llmProvider = new LLMProvider(() => this.settings);
    const dependencies = {
      persistence: this.persistence,
      eventBus: this.eventBus,
      getSettings: () => this.settings
    };
    this.orchestrator = new Orchestrator(dependencies);
    await this.orchestrator.loadInitialQueueData();
    const getPluginSettings = () => this.settings;
    const agentContext = {
      get settings() {
        return getPluginSettings();
      },
      app: this.app,
      persistence: {
        saveTaskCache: (id, content) => this.persistence.saveTaskCache(id, content),
        loadTaskCache: (id) => this.persistence.loadTaskCache(id),
        deleteTaskCache: (id) => this.persistence.deleteTaskCache(id)
      },
      orchestrator: {
        addToQueue: async (queueName, item) => this.orchestrator.addToQueue(queueName, item)
      },
      triggerEvent: (event, data) => this.eventBus.emit(event, data)
    };
    this.orchestrator.registerAgent(new GeneratorAgent(agentContext, this.llmProvider));
    this.addSettingTab(new OAKSettingTab(this.app, this));
    this.addCommand({
      id: "add-custom-concept",
      name: "æ·»åŠ æ–°æ¦‚å¿µåˆ°ç”Ÿæˆé˜Ÿåˆ—",
      callback: () => {
        new InputModal(this.app, (concept) => {
          this.api.dispatch(GeneratorAgent.QUEUE_NAME, { concept }, "OAK-GUI").then((taskId) => new import_obsidian8.Notice(`å·²å°† '${concept}' åŠ å…¥é˜Ÿåˆ— (ID: ${taskId})ã€‚`)).catch((err) => new import_obsidian8.Notice(`æ·»åŠ åˆ°é˜Ÿåˆ—å¤±è´¥: ${err.message}`));
        }).open();
      }
    });
    this.addCommand({
      id: "toggle-oak",
      name: "å¯åŠ¨/åœæ­¢ OAK å¼•æ“",
      callback: () => {
        if (this.orchestrator.isRunning) {
          this.orchestrator.stop();
        } else {
          this.orchestrator.start();
        }
      }
    });
    this.addRibbonIcon("bot", "OAK: æ·»åŠ æ–°æ¦‚å¿µ", () => {
      new InputModal(this.app, (concept) => {
        this.api.dispatch(GeneratorAgent.QUEUE_NAME, { concept }, "OAK-Ribbon").then((taskId) => new import_obsidian8.Notice(`å·²å°† '${concept}' åŠ å…¥é˜Ÿåˆ— (ID: ${taskId})ã€‚`)).catch((err) => new import_obsidian8.Notice(`æ·»åŠ åˆ°é˜Ÿåˆ—å¤±è´¥: ${err.message}`));
      }).open();
    });
    Logger.log("OAK Agent Kit (Framework Mode) loaded.");
  }
  onunload() {
    this.orchestrator.stop();
    Logger.log("OAK Agent Kit unloaded.");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  get api() {
    return {
      version: this.manifest.version,
      registerAgent: (agent) => {
        const getApiSettings = () => this.settings;
        const agentContext = {
          get settings() {
            return getApiSettings();
          },
          app: this.app,
          persistence: {
            saveTaskCache: (id, content) => this.persistence.saveTaskCache(id, content),
            loadTaskCache: (id) => this.persistence.loadTaskCache(id),
            deleteTaskCache: (id) => this.persistence.deleteTaskCache(id)
          },
          orchestrator: {
            addToQueue: async (queueName, item) => this.orchestrator.addToQueue(queueName, item)
          },
          triggerEvent: (event, data) => this.eventBus.emit(event, data)
        };
        this.orchestrator.registerAgent(agent);
      },
      dispatch: async (queueName, payload, sourcePluginId) => {
        const item = { ...payload, sourcePluginId: sourcePluginId || "External" };
        const taskId = await this.orchestrator.addToQueue(queueName, item);
        if (!this.orchestrator.isRunning) {
          this.orchestrator.start();
        }
        return taskId;
      },
      chat: async (prompt) => {
        return await this.llmProvider.chat(prompt);
      },
      on: (event, callback) => {
        this.eventBus.on(event, callback);
      },
      off: (event, callback) => {
        this.eventBus.off(event, callback);
      }
    };
  }
};
