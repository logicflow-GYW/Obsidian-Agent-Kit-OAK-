/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
If you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AgentKitPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/core/Orchestrator.ts
var import_obsidian2 = require("obsidian");

// src/core/EventBus.ts
var import_obsidian = require("obsidian");

// src/core/utils.ts
var _Logger = class {
  static setDebugMode(debug) {
    _Logger.isDebug = debug;
  }
  static log(message, ...args) {
    if (_Logger.isDebug) {
      console.log(`[OAK] ${message}`, ...args);
    }
  }
  static warn(message, ...args) {
    console.warn(`[OAK] ${message}`, ...args);
  }
  static error(message, ...args) {
    console.error(`[OAK] ${message}`, ...args);
  }
};
var Logger = _Logger;
Logger.isDebug = false;

// src/core/EventBus.ts
var EventBus = class extends import_obsidian.Events {
  constructor() {
    super();
  }
  static getInstance() {
    if (!EventBus.instance) {
      EventBus.instance = new EventBus();
    }
    return EventBus.instance;
  }
  // å°è£… emit ä»¥ä¾¿ç»Ÿä¸€è®°å½•æ—¥å¿—
  emit(eventName, ...args) {
    Logger.log(`[EventBus] Emitting: ${eventName}`, args);
    super.trigger(eventName, ...args);
  }
};
var OakEvents = {
  TASK_ADDED: "oak:task-added",
  TASK_STARTED: "oak:task-started",
  TASK_COMPLETED: "oak:task-completed",
  // æˆåŠŸ
  TASK_FAILED: "oak:task-failed",
  // å¤±è´¥ï¼ˆå¯èƒ½é‡è¯•ï¼‰
  TASK_DISCARDED: "oak:task-discarded",
  // å½»åº•æ”¾å¼ƒ
  WORKFLOW_COMPLETE: "oak:workflow-complete"
};

// src/core/Orchestrator.ts
var Orchestrator = class {
  constructor(plugin) {
    this._isRunning = false;
    this.agents = [];
    this.plugin = plugin;
    this.eventBus = EventBus.getInstance();
  }
  get isRunning() {
    return this._isRunning;
  }
  registerAgent(agent) {
    this.agents.push(agent);
    if (!this.plugin.queueData[agent.queueName]) {
      this.plugin.queueData[agent.queueName] = [];
    }
    Logger.log(`Registered Agent: ${agent.constructor.name} -> Queue: ${agent.queueName}`);
  }
  async addToQueue(queueName, item) {
    if (!this.plugin.queueData[queueName]) {
      this.plugin.queueData[queueName] = [];
    }
    item.retries = item.retries || 0;
    if (!item.id)
      item.id = Date.now().toString() + Math.random().toString(36).substr(2, 5);
    if (!item.timestamp)
      item.timestamp = Date.now();
    this.plugin.queueData[queueName].push(item);
    await this.plugin.persistence.saveQueueData(this.plugin.queueData);
    this.eventBus.emit(OakEvents.TASK_ADDED, { queueName, task: item });
    Logger.log(`Task added to ${queueName} (Source: ${item.sourcePluginId || "System"})`);
  }
  start() {
    if (this._isRunning)
      return;
    this._isRunning = true;
    new import_obsidian2.Notice("ğŸš€ OAK å¼•æ“å·²å¯åŠ¨");
    Logger.log("Engine started");
    this.loop().catch((err) => Logger.error("Loop error:", err));
  }
  stop() {
    this._isRunning = false;
    new import_obsidian2.Notice("ğŸ›‘ OAK å¼•æ“å·²åœæ­¢");
    Logger.log("Engine stopped");
  }
  async loop() {
    if (!this._isRunning)
      return;
    let workDone = false;
    for (const agent of this.agents) {
      if (!this._isRunning)
        break;
      const queueName = agent.queueName;
      const queue = this.plugin.queueData[queueName];
      if (queue && queue.length > 0) {
        const item = queue[0];
        try {
          Logger.log(`Processing task in ${queueName}...`);
          this.eventBus.emit(OakEvents.TASK_STARTED, { queueName, task: item });
          const result = await agent.process(item);
          const isSuccess = typeof result === "boolean" ? result : result.status === "success";
          if (isSuccess) {
            queue.shift();
            workDone = true;
            const outputData = typeof result === "object" ? result.data : null;
            this.eventBus.emit(OakEvents.TASK_COMPLETED, {
              queueName,
              taskId: item.id,
              result: outputData
            });
            if (typeof result === "object" && result.nextTasks && result.nextTasks.length > 0) {
              Logger.log(`ğŸ”— Triggering ${result.nextTasks.length} next tasks`);
              for (const next of result.nextTasks) {
                await this.addToQueue(next.queueName, {
                  ...next.payload,
                  sourcePluginId: "OAK-Chaining",
                  // æ ‡è®°ä¸ºå†…éƒ¨é“¾å¼è§¦å‘
                  parentId: item.id
                });
              }
            }
          } else {
            throw new Error(typeof result === "object" ? result.message : "Agent process returned false");
          }
        } catch (error) {
          this.handleFailure(queue, item, queueName, error);
          workDone = true;
        } finally {
          await this.plugin.persistence.saveQueueData(this.plugin.queueData);
        }
      }
    }
    const delay = workDone ? 100 : 2e3;
    if (this._isRunning) {
      setTimeout(() => {
        this.loop().catch((err) => Logger.error("Loop timeout error:", err));
      }, delay);
    }
  }
  handleFailure(queue, item, queueName, error) {
    Logger.error(`Agent failed in ${queueName}:`, error);
    const failedItem = queue.shift();
    if (failedItem) {
      failedItem.retries = (failedItem.retries || 0) + 1;
      const maxRetries = this.plugin.settings.maxRetries || 3;
      if (failedItem.retries < maxRetries) {
        queue.push(failedItem);
        this.eventBus.emit(OakEvents.TASK_FAILED, { queueName, task: failedItem, error });
        Logger.warn(`Task retrying (${failedItem.retries}/${maxRetries})`);
      } else {
        this.eventBus.emit(OakEvents.TASK_DISCARDED, { queueName, task: failedItem, error });
        Logger.error(`Task max retries reached. Discarding.`);
        new import_obsidian2.Notice(`ä»»åŠ¡å·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œå·²è¢«æ”¾å¼ƒã€‚`);
      }
    }
  }
};

// src/core/LLMProvider.ts
var import_obsidian3 = require("obsidian");
var LLMProvider = class {
  constructor(getSettings) {
    this.getSettings = getSettings;
  }
  async chat(prompt) {
    const settings = this.getSettings();
    const provider = settings.llmProvider;
    try {
      if (provider === "openai") {
        return await this.callOpenAI(prompt);
      } else if (provider === "google") {
        return await this.callGoogle(prompt);
      } else {
        throw new Error(`æœªçŸ¥çš„æä¾›å•†: ${provider}`);
      }
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      console.error("[LLM Error]", error);
      new import_obsidian3.Notice(`AI è°ƒç”¨å¤±è´¥: ${msg}`);
      return "";
    }
  }
  async callOpenAI(prompt) {
    const settings = this.getSettings();
    if (!settings.openaiApiKey)
      throw new Error("OpenAI API Key æœªé…ç½®");
    const url = `${settings.openaiBaseUrl.replace(/\/$/, "")}/chat/completions`;
    const response = await (0, import_obsidian3.requestUrl)({
      url,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${settings.openaiApiKey}`
      },
      body: JSON.stringify({
        model: settings.openaiModel,
        messages: [{ role: "user", content: prompt }],
        temperature: 0.7
      })
    });
    if (response.status >= 400) {
      throw new Error(`OpenAI API Error: ${response.status}`);
    }
    return response.json.choices[0].message.content.trim();
  }
  async callGoogle(prompt) {
    const settings = this.getSettings();
    if (!settings.googleApiKey)
      throw new Error("Google API Key æœªé…ç½®");
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${settings.googleModel}:generateContent?key=${settings.googleApiKey}`;
    const response = await (0, import_obsidian3.requestUrl)({
      url,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        contents: [{ parts: [{ text: prompt }] }]
      })
    });
    if (response.status >= 400) {
      throw new Error(`Google API Error: ${response.status}`);
    }
    if (response.json.candidates && response.json.candidates.length > 0) {
      return response.json.candidates[0].content.parts[0].text.trim();
    }
    return "";
  }
};

// src/core/Persistence.ts
var import_obsidian4 = require("obsidian");
var Persistence = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = plugin.app;
    this.cacheDir = (0, import_obsidian4.normalizePath)(`${this.app.vault.configDir}/plugins/${this.plugin.manifest.id}/task_cache`);
    this.queueFile = (0, import_obsidian4.normalizePath)(`${this.app.vault.configDir}/plugins/${this.plugin.manifest.id}/queues.json`);
  }
  async init() {
    const adapter = this.app.vault.adapter;
    if (!await adapter.exists(this.cacheDir)) {
      await adapter.mkdir(this.cacheDir);
    }
  }
  // --- é˜Ÿåˆ—æ•°æ®ç®¡ç† ---
  async loadQueueData() {
    const adapter = this.app.vault.adapter;
    if (await adapter.exists(this.queueFile)) {
      try {
        const content = await adapter.read(this.queueFile);
        return JSON.parse(content);
      } catch (e) {
        Logger.error("Failed to load queue data:", e);
        return {};
      }
    }
    return {};
  }
  async saveQueueData(queues) {
    const adapter = this.app.vault.adapter;
    try {
      await adapter.write(this.queueFile, JSON.stringify(queues, null, 2));
      Logger.log("Queue data saved.");
    } catch (e) {
      Logger.error("Failed to save queue data:", e);
    }
  }
  // --- ä»»åŠ¡å†…å®¹ç¼“å­˜ (ç”¨äº Agent é—´ä¼ é€’å¤§æ•°æ®) ---
  getCachePath(taskId) {
    const safeName = taskId.replace(/[\\/*?:"<>|]/g, "").trim();
    return `${this.cacheDir}/${safeName}.md`;
  }
  async saveTaskCache(taskId, content) {
    const path = this.getCachePath(taskId);
    try {
      await this.app.vault.adapter.write(path, content);
      Logger.log(`Saved task cache: ${taskId}`);
    } catch (e) {
      Logger.error(`Failed to save task cache for ${taskId}:`, e);
    }
  }
  async loadTaskCache(taskId) {
    const path = this.getCachePath(taskId);
    try {
      if (await this.app.vault.adapter.exists(path)) {
        return await this.app.vault.adapter.read(path);
      }
    } catch (e) {
      Logger.error(`Failed to load task cache for ${taskId}:`, e);
    }
    return "";
  }
  async deleteTaskCache(taskId) {
    const path = this.getCachePath(taskId);
    try {
      if (await this.app.vault.adapter.exists(path)) {
        await this.app.vault.adapter.remove(path);
        Logger.log(`Deleted task cache: ${taskId}`);
      }
    } catch (e) {
      Logger.warn(`Failed to delete task cache for ${taskId}:`, e);
    }
  }
};

// src/core/BaseAgent.ts
var BaseAgent = class {
  constructor(plugin, llm) {
    this.plugin = plugin;
    this.llm = llm;
  }
  get settings() {
    return this.plugin.settings;
  }
  get app() {
    return this.plugin.app;
  }
  log(msg) {
    Logger.log(`[${this.constructor.name}] ${msg}`);
  }
  error(msg, ...args) {
    Logger.error(`[${this.constructor.name}] ${msg}`, ...args);
  }
};

// src/agents/GeneratorAgent.ts
var _GeneratorAgent = class extends BaseAgent {
  get queueName() {
    return _GeneratorAgent.QUEUE_NAME;
  }
  async process(item) {
    console.debug(`[GeneratorAgent] æ­£åœ¨å¤„ç†æ¦‚å¿µ: ${item.concept}`);
    const prompt = this.settings.prompt_generator.replace("{concept}", item.concept);
    const content = await this.llm.chat(prompt);
    if (!content || content.trim().length === 0) {
      console.error("[GeneratorAgent] LLM è¿”å›å†…å®¹ä¸ºç©ºã€‚");
      return false;
    }
    const outputDir = this.settings.output_dir;
    const fileName = `${item.concept.replace(/[\\/:"*?<>|]/g, "_")}.md`;
    const filePath = `${outputDir}/${fileName}`;
    const fileExists = await this.app.vault.adapter.exists(filePath);
    if (fileExists) {
      console.warn(`[GeneratorAgent] æ–‡ä»¶å·²å­˜åœ¨ï¼Œè·³è¿‡åˆ›å»º: ${filePath}`);
      return true;
    }
    await this.app.vault.create(filePath, content);
    console.debug(`[GeneratorAgent] å·²æˆåŠŸåˆ›å»ºæ–‡ä»¶: ${filePath}`);
    return true;
  }
};
var GeneratorAgent = _GeneratorAgent;
GeneratorAgent.QUEUE_NAME = "generation_queue";

// src/settings.ts
var import_obsidian5 = require("obsidian");
var OAKSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian5.Setting(containerEl).setName("General").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Debug mode").setDesc("Enable verbose logging in console for troubleshooting.").addToggle((toggle) => toggle.setValue(this.plugin.settings.debug_mode).onChange(async (value) => {
      this.plugin.settings.debug_mode = value;
      Logger.setDebugMode(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("AI Model Provider").addDropdown((d) => d.addOption("openai", "OpenAI").addOption("google", "Google").setValue(this.plugin.settings.llmProvider).onChange(async (v) => {
      this.plugin.settings.llmProvider = v;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.llmProvider === "openai") {
      new import_obsidian5.Setting(containerEl).setName("OpenAI").setHeading();
      new import_obsidian5.Setting(containerEl).setName("API Key").addText((t) => t.setValue(this.plugin.settings.openaiApiKey).onChange(async (v) => {
        this.plugin.settings.openaiApiKey = v;
        await this.plugin.saveSettings();
      }));
      new import_obsidian5.Setting(containerEl).setName("Base URL").addText((t) => t.setValue(this.plugin.settings.openaiBaseUrl).onChange(async (v) => {
        this.plugin.settings.openaiBaseUrl = v;
        await this.plugin.saveSettings();
      }));
      new import_obsidian5.Setting(containerEl).setName("Model Name").addText((t) => t.setValue(this.plugin.settings.openaiModel).onChange(async (v) => {
        this.plugin.settings.openaiModel = v;
        await this.plugin.saveSettings();
      }));
    }
    if (this.plugin.settings.llmProvider === "google") {
      new import_obsidian5.Setting(containerEl).setName("Google Gemini").setHeading();
      new import_obsidian5.Setting(containerEl).setName("API Key").addText((t) => t.setValue(this.plugin.settings.googleApiKey).onChange(async (v) => {
        this.plugin.settings.googleApiKey = v;
        await this.plugin.saveSettings();
      }));
      new import_obsidian5.Setting(containerEl).setName("Model Name").addText((t) => t.setValue(this.plugin.settings.googleModel).onChange(async (v) => {
        this.plugin.settings.googleModel = v;
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian5.Setting(containerEl).setName("Engine").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Output Folder").addText((t) => t.setValue(this.plugin.settings.output_dir).onChange(async (v) => {
      this.plugin.settings.output_dir = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Max Retries").setDesc("How many times to retry a failed task.").addText((t) => t.setValue(String(this.plugin.settings.maxRetries)).onChange(async (v) => {
      const num = parseInt(v);
      if (!isNaN(num)) {
        this.plugin.settings.maxRetries = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian5.Setting(containerEl).setName("Generator Prompt Template").addTextArea((t) => {
      t.setValue(this.plugin.settings.prompt_generator).onChange(async (v) => {
        this.plugin.settings.prompt_generator = v;
        await this.plugin.saveSettings();
      });
      t.inputEl.rows = 5;
      t.inputEl.style.width = "100%";
    });
  }
};

// src/InputModal.ts
var import_obsidian6 = require("obsidian");
var InputModal = class extends import_obsidian6.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "ğŸŒ± æ’­ç§æ–°æ¦‚å¿µ" });
    let inputElement;
    new import_obsidian6.Setting(contentEl).setName("è¾“å…¥æ¦‚å¿µåç§°").setDesc("è¾“å…¥ä½ æƒ³ç”Ÿæˆçš„çŸ¥è¯†ç‚¹ï¼Œä¾‹å¦‚ï¼š'ç¬¬ä¸€æ€§åŸç†'").addText((text) => {
      inputElement = text.inputEl;
      text.onChange((value) => {
        this.result = value;
      });
      text.inputEl.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          this.submit();
        }
      });
    });
    new import_obsidian6.Setting(contentEl).addButton((btn) => btn.setButtonText("æ·»åŠ åˆ°é˜Ÿåˆ—").setCta().onClick(() => {
      this.submit();
    }));
    setTimeout(() => inputElement == null ? void 0 : inputElement.focus(), 0);
  }
  submit() {
    if (this.result && this.result.trim().length > 0) {
      this.close();
      this.onSubmit(this.result.trim());
    } else {
      this.close();
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  llmProvider: "openai",
  openaiApiKey: "",
  openaiBaseUrl: "https://api.openai.com/v1",
  openaiModel: "gpt-3.5-turbo",
  googleApiKey: "",
  googleModel: "gemini-1.5-flash",
  maxRetries: 3,
  prompt_generator: "è¯·è¯¦ç»†è§£é‡Šæ¦‚å¿µ: {concept}ï¼ŒåŒ…å«å®šä¹‰ã€åŸç†å’Œåº”ç”¨ã€‚",
  output_dir: "KnowledgeGraph",
  debug_mode: false
};
var AgentKitPlugin = class extends import_obsidian7.Plugin {
  // --- æ ¸å¿ƒï¼šæš´éœ² API ç»™å…¶ä»–æ’ä»¶ ---
  get api() {
    return {
      version: this.manifest.version,
      registerAgent: (agent) => this.orchestrator.registerAgent(agent),
      dispatch: async (queueName, payload, sourcePluginId) => {
        const item = { ...payload, sourcePluginId: sourcePluginId || "External" };
        await this.orchestrator.addToQueue(queueName, item);
        if (!this.orchestrator.isRunning)
          this.orchestrator.start();
        return item.id;
      },
      on: (event, cb) => this.eventBus.on(event, cb),
      off: (event, cb) => this.eventBus.off(event, cb)
    };
  }
  // ------------------------------
  async onload() {
    await this.loadSettings();
    Logger.setDebugMode(this.settings.debug_mode);
    this.persistence = new Persistence(this);
    await this.persistence.init();
    this.queueData = await this.persistence.loadQueueData();
    this.eventBus = EventBus.getInstance();
    if (!await this.app.vault.adapter.exists(this.settings.output_dir)) {
      await this.app.vault.createFolder(this.settings.output_dir);
    }
    this.addSettingTab(new OAKSettingTab(this.app, this));
    this.llm = new LLMProvider(() => this.settings);
    this.orchestrator = new Orchestrator(this);
    this.orchestrator.registerAgent(new GeneratorAgent(this, this.llm));
    this.addCommand({
      id: "add-custom-concept",
      name: "æ·»åŠ æ–°æ¦‚å¿µåˆ°ç”Ÿæˆé˜Ÿåˆ—",
      callback: () => {
        new InputModal(this.app, (concept) => {
          this.api.dispatch(GeneratorAgent.QUEUE_NAME, { concept }, "OAK-GUI").then(() => new import_obsidian7.Notice(`å·²å°† '${concept}' åŠ å…¥é˜Ÿåˆ—ã€‚`));
        }).open();
      }
    });
    this.addCommand({
      id: "toggle-oak",
      name: "å¯åŠ¨/åœæ­¢ OAK å¼•æ“",
      callback: () => {
        if (this.orchestrator.isRunning) {
          this.orchestrator.stop();
        } else {
          this.orchestrator.start();
        }
      }
    });
    this.addRibbonIcon("bot", "OAK: æ·»åŠ æ–°æ¦‚å¿µ", () => {
      new InputModal(this.app, (concept) => {
        this.api.dispatch(GeneratorAgent.QUEUE_NAME, { concept }, "OAK-Ribbon");
      }).open();
    });
    Logger.log("OAK Agent Kit (Framework Mode) loaded.");
  }
  onunload() {
    this.orchestrator.stop();
    Logger.log("OAK Agent Kit unloaded.");
  }
  async loadSettings() {
    const loaded = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loaded);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
